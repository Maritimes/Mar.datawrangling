% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_filter.r
\name{data_filter}
\alias{data_filter}
\title{data_filter}
\usage{
data_filter(db = .GlobalEnv$db, refresh.data = FALSE, safe = TRUE)
}
\arguments{
\item{db}{default is \code{NULL}. This identifies the dataset you are working 
with.}

\item{refresh.data}{default is \code{FALSE}.  The purpose of this function is to filter the 
data you have stored on your computer to get the records you're interested in.  If this is set to
FALSE, you can perform multiple filters on the same data.  If it is set to TRUE, any filtered
data will be discarded, and the raw data will be reloaded - all previous filtering will be lost.}

\item{safe}{default is \code{TRUE}.  If TRUE, this will ensure that selection 
boxes are only populated with viable options.  If FALSE, invalid values are 
possible.  Turning this off omits the initial self_filter(), and causes the 
script to run faster.  It's only advisable if you know your selections are 
appropriate, and in that case, it's a good idea.}
}
\value{
list of the filters that were applied to generate the remaining dataset
}
\description{
This is a GUI-driven script. It loads stored data objects into the
workspace, and presents the user with a bunch of methods for filtering. As filters are
applied, the data objects in the workspace are whittled down such that the only data that is
presented in successive filters directly applies to the users' previous selections.
For example, if the user only wants data where the species caught is halibut, all records where
caught species is not halibut are dropped, and this might mean that certain areas, gears,
vessels, etc will also be dropped, since they are not associated with catches of halibut.
}
\note{
If editing, please be aware of the scope of the data - the approach was to load the data into the
global environment, and then do all the filtering there.  This is why subsets require
\code{assign(..., envir = GlobalEnv)} and references to \code{envir = GlobalEnv} are littered
everywhere.

This line is here to prevent an error message claiming the export is mult-line
This function prompts the user to provide the bounding coordinates for an area of
interest. Values for longitude are automatically converted to negative if they were not provided
that way.  While it asks for specific values for N/S and E/W values, the script determines the
users intent by look at the max and min values provided.
it returns a vector of 4 values, corresponding with c(N, S, E, W)
interest.  If cancelled during the "start" date selections, it will get the minimum/earliest
values, if cancelled during the "end" date selection, it will get the maximimum/most recent
values.
It returns a vector of 2 dates corresponding with the selected start and end values
create the select list, and order it as specified
Vessels are a pain - replace special chars and remove spaces
}
\seealso{
Other dfo_extractions: \code{\link{get_data_custom}},
  \code{\link{get_data}}, \code{\link{self_filter}},
  \code{\link{summarize_catches}}
}
\author{
Mike McMahon, \email{Mike.McMahon@dfo-mpo.gc.ca}
}
